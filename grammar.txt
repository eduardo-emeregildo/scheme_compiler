 <file> ::= <form>*     ;This is what LOAD presumably parses
  <form> ::= <expression> | <definition>
                  ;This is what a read-eval-print might parse

  <expression> ::= <constant> | <variable>
      | <procedure call>
      | <quotation>
      | (lambda <bound var list> <body>)
      | (if <test> <consequent> <alternate>)
      | (if <test> <consequent>)
      | (cond <cond clause>*)
      | (cond <cond clause>* (else <sequence>))
      | (and <expression>*)
      | (or <expression>*)
      | (case <expression> <case clause>*)
      | (case <expression> <case clause>* (else <sequence>))
      | (let (<binding spec>*) <body>)
      | (let <variable> (<binding spec>*) <body>)
      | (let* (<binding spec>*) <body>)
      | (letrec (<binding spec>*) <body>)
      | (rec <variable> <expression>)
      | (set! <variable> <expression>)
      | (begin <sequence>)
      | (do (<iteration spec>*) (<end test> <sequence>+) <expression>*)
      | (delay <expression>)
      | <quasiquotation>

  <variable> ::= <identifier>

  <procedure call> ::= (<operator> <operand>*)
  <operator> ::= <expression>
  <operands> ::= <expression>*

  <quotation> ::= '<datum> | (quote <datum>)
  <body> ::= <definition>* <sequence>
  <sequence> ::= <expression>

  <definition> ::= (define <variable> <expression>)
      | (define <call pattern> <body>)

  <call pattern> ::= (<pattern> <variable>*)
      | (<pattern> <variable>* . <variable>)

  <pattern> ::= <variable> | <call pattern>

  <bound var list> ::= <variable>
      | (<variable>*) | (<variable>+ . <variable>)

  <test> ::= <expression>
  <consequent> ::= <expression>
  <alternate> ::= <expression>

  <cond clause> ::= (<test> <sequence>)

  <case clause> ::= ((<datum>*) <sequence>)

  <binding spec> ::= (<variable> <expression>)

  <iteration spec> ::= (<variable> <init> <step>)


  <quasiquotation> ::= <quasiquotation 0>

  <template 0> ::= <expression>

  Repeat the following for N = 1 to infinity:

    <quasiquotation N> ::=  `<template N+1> | (quasiquote <template N+1>)

    <template N> ::= <constant> | <symbol>
        | <list template N>
	| <vector template N>
	| <unquotation N>

    <seq template N> ::= <template N> | <splicing unquotation N>

    <list template N> ::= (<seq template N>*)
	| (<seq template N>+ . <template N>)
	| <quasiquotation N+1>

    <vector template N> ::= #(<seq template N>*)

    <unquotation N> ::= ,<template N-1> | (unquote <template N-1>)
    <splicing unquotation N> ::= ,@<template N-1>
        | (unquote-splicing <template N-1>)

  end repeat


The grammar for external representations of objects from here on down is
self-contained.  <datum> is what READ parses.  Note that any string
which is an <expression> must also be a <datum>.

  <datum> ::= <constant> | <symbol> | <list> | <vector>

  <constant> ::= <boolean> | <number> | <character> | <string>

  <symbol> ::= <identifier>

  <boolean> ::= #!true | #!false

  <string> ::= " <string element>* "
  <string element> ::= <any character other than " or \> | \" | \\

  <list> ::= ( <datum>* ) | ( <datum>+ . <datum> )
      | <abbreviation>

  <abbreviation> ::= <abbrev prefix> <datum>
  <abbrev prefix> ::= ' | ` | , | ,@

  <vector> ::= #( <datum>* )


  <identifier> ::= <initial> <subsequent>* | <peculiar identifier>
  <initial> ::= <letter> | <special initial>
  <letter> ::= A | B | C | ... | Z
  <special initial> ::= ! | $ | % | & | * | / | : | < | = | > | ? | ~ | _ | ^
  <subsequent> ::= <initial> | <digit> | <special subsequent>
  <digit> ::= 0 | 1 | ... | 9
  <special subsequent> ::= . | + | -
  <peculiar identifier> ::= + | - | 1+ | -1+


  <number> ::= ... the grammar for numbers ...